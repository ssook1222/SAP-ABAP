# Unit5 - System Core

## Lesson1 - 어플리케이션 시스템 ABAP과 자바의 아키텍쳐

7.0과 그 하위버전에서 SAP 넷위버 설치 가능한 타입

- 설치 방법 3개
    - Abap 스택만 올리는 경우 
  - Java 스택만 올리는 경우 
  - 두 개 스택 다 올리는 경우 : 잘 안 씀. 두 개 다 올리면 리소스가 많이 들기 때문.
    
7.1부터는 자바 요청을 Dispatcher가 아닌 ICM이 처리함


## ABAP 시스템 아키텍처

파란 사각형이 Application Server : ABAP이라고 생각하기     
위 녹색 사각형은 User가 접하는 Application Layer임.    

Central Instance는 단 1개로, 그냥 Dialog Instance와 분류하는 방법은 두 가지임.

**1. ABAP Message Server - dispatcher들 사이의 통신을 담당하는 역할**    
유저가 로그온할 때 dispatcher로 요청이 가는 것이 아니라,      
   유저가 MS에 붙어 지금 일을 하지 않는 곳으로 연결하는 로그온 로드밸런싱 작업을 수행함.
- 디스패처와 디스패처와의 통신을 담당 
- 로그온 로드밸런싱 수행      

**2. ABAP Enqueue 서버**
- GW : 게이트웨이로 시스템 간의 연결을 할 때 사용
- ICM : http, java 요청이 들어왔을 때 처리 
- Dispatcher : 실제 유저 요청을 받음
- D, V, E, B, S : 여러 워크 플로우들이 진행되고 있음.

워크 프로세스 종류에는 여러가지가 있음.

## Lesson2 - Identifying the Processes of an AS ABAP System

프로세스는 크게 
- MS(message Server) 
    - 디스패처들 사이의 통신을 담당
    - 로그온 로드밸런싱 수행
- GW(GateWay)
    - 시스템과 시스템 사이의 연결
- ICM(Internet Communication Manager)
  - Http 요청을 받아 ABAP 혹은 JAVA 쪽으로 넘김
- ABAP Distpatcher : 사용자의 요청을 받아 그 밑에 알맞은 워크 프로세스들로 일을 분배함.
    - workflow
        - Dialog : 유저에 의한 생성된 요청을 처리하는 역할.      
          디스패처 당 최소 2개(응답, 요청)의 다이얼로그 워크 프로세스가 필요함. 
        - Background : 주기적으로 batch 작업을 처리하는 역할, 최소 1개 필요
        - Lock Management(Enqueue) : 논리적인 LOCK을 처리함.   
            `예) A 레코드를 변경하는 동안 B가 접근 못하게끔 LOCK 걸음. 단지 1개만 필요`
        - Update : 업데이트 리퀘스트를 처리하는 역할, 최소 1개의 워크프로세스가 필요
        - Spool : 데이터를 프린터로 보내는 역할을 담당.    
          SAP 시스템 당 최소 1개의 워크 프로세스가 필요함.
          
## LESSON3 : Application Server for ABAP에서 User Request를 처리하는 방법

- Abap에서 유저 요청을 처리하는 방법

1. presentation layer에서 gui를 통해서 접속
2. 접속하면 ABAP Dispatcher에 붙음
3. 사용자가 요청을 날리면 ABAP dispatcher가 해당 요청을 받음.
4. 그 요청을 request queue에다가 쌓아 놓음. 큐이기 때문에 FIFO.
5. 그 요청의 차례가 왔을 때 dispatcher가 work process로 요청을 날림.

Dialog workprocess가 요청을 처리할 때 데이터베이스로부터 어떤 값을 받아와야한다면, 데이터베이스 인터페이스라는 것을 통해 값을 읽어와 반환
6. 이때 반환된 데이터를 바로 유저에게 보내는 것이 아니라 Buffer 단에 쌓아 놓음. 버퍼에 쌓고 해당 데이터를 유저에게 반환하는 것으로 되어 있음
똑같은 데이터로 요청이 들어왔을 때는 데이터베이스 인터페이스가 데이터베이스 레벨까지 접근하지 않고 버퍼에 있는 데이터를 가져와서 사용자에게 리턴

`유저 요청 처리 방법`        
GUI를 통해 유저가 요청을 날리면, 디스패처가 이를 받아 리퀘스트 큐에 요청을 쌓아놨다가 큐에서 요청을 하나하나 빼 내서 밑에 있는 워크 프로세스들로 분배하는 형식



워크프로세스 안에 보면, 
- 스크린 프로세서 : 화면에 대한 로직을 담당
- ABAP 인터프리터 : ABAP 로직을 담당
- 데이터베이스 인터페이스 : 데이터베이스의 접근을 담당
요청이 들어오면 스크린 프로세서가 화면을 먼저 분석하면서, 이 안에 있는 로직들을 ABAP 인터프리터가 분석함.     
  이 때 데이터베이스에 대한 접근이 필요할 경우 데이터베이스 인터페이스를 통해 데이터베이스에 들어감.



`(+) Task Handler`

Roll in/out이라는 작업을 수행
워크 프로세스 입장에서 보면, 워크 프로세서는 어느 유저가 쓰는지에 대한 관심이 없음. 요청만 처리할 뿐 어떤 유저가 보낸 것인지 모름.      
만약, 워크프로세서가 어느 유저가 보낸 것인지 정보를 안다면 (=워크프로세서와 유저 사이에 세션이 맺어진다면) 다이얼로그 워크 프로세스의 개수와 접근할 수 있는 유저의 수가 동일해야 됨. 이렇게 되면 다이얼로그 워크 프로세스의 수가 3개면, 접근 가능한 유저의 수가 3명으로 제한됨.
따라서 워크 프로세스는 유저 당 Assign되는 것이 아니라 짧은 request당 task를 수행하고 다시 풀리는 방식로 진행됨.
그렇기에 요청을 보낸 유저의 정보(User Context)를 알기 위해서는 Shared Memory에 와서 유저 요청을 처리해야 함.     
이렇게 유저의 요청을 처리할 때 Shared Memory의 데이터를 읽는 것을 Roll in, Shared Memory의 데이터를 반납하여 다른 워크 프로세스가 쓸 수 있게끔 Overwrite하는 것 Roll Out이라고 함.    
Roll in과 Roll Out을 사용하여 데이터를 처리한다고 보면 됨.

`데이터베이스 인터페이스`    
데이터베이스 인터페이스는 데이터베이스의 접근을 담당.
워크프로세스 ABAP 인터프리터가 SQL 조회 구문을 만남.
인터프리터가 DB 인터페이스로 해당 요청을 Open SQL로 넘김.

`Open SQL`     
ABAP 언어에서 사용하는 SQL
DB 인터페이스가 해당 요청을 데이터베이스에게 Native SQL로 넘김.

`Native SQL`    
각 데이터베이스 Vendor 사마다 Dependent한 SQL.     
그래서 SAP 시스템은 데이터베이스 독립적, 어떤 데이터베이스인지가 중요하지 않음.    
SAP 개발자는 데이터베이스 언어가 어떤 것인지와는 관계없이 전부 OpenSQL로 원하는 쿼리를 날리면 됨. 그것을 가능하게 해주는 것이 데이터베이스 인터페이스.

`데이터베이스 인터페이스의 역할`     
데이터베이스 인터페이스는 OPEN SQL을 Native SQL로 변환해 줌

`로컬 버퍼`
로컬 버퍼를 사용가능하게 해 줌. SQL문의 결과가 있다면 바로 리턴해주고 또 없다면 버퍼에 저장해줌.

- ABAP에서도 Native SQL 사용 가능

`Native 사용방법)`     
사용하고자 하는 Native SQL 앞뒤로 EXEC SQL / END EXEC를 작성하면 됨.

[예제]

```abap
EXEC SQL

SELECT …

END EXEC
```
버퍼링 기능도 못하고, 문법 체크도 안 되기 때문에 이 방법은 지양함.

`Multiplexing of Dialog Work Processes`

다이얼로그 워크 프로세스는 한 유저의 요청만을 처리하는 것이 아니라 여러 명 유저의 요청을 처리함. 유저와 세션을 맺지 않음!    
그때 유휴 다이얼로그 프로세스가 맞게 처리하므로 그때그때 처리하는 다이얼로그 워크 프로세스가 달라짐.
여러 개의 다이얼로그 워크 프로세스에서 하나의 요청이 될 수 있음.     

`데이터베이스와 SAP 트랜잭션과의 관계`

스크린 3개가 모두 하나의 프로그램에 속해 있고, 같은 데이터베이스로 업데이트 요청을 보낸다고 하자.      
해당 트랜잭션에서 첫번째 프로세스부터 순차적으로 두번째 프로세스, 세번째 프로세스를 거쳐 작업을 한다고 할 때 세번째 프로세스에서 프로그램을 종료하면,   
이전 프로세스에서 작업했던 것은 결코 저장이 되면 안 됨.    

SAP 워크 프로세스에서는 짧게 짧게 한 번씩 워크 프로세스가 실행되기 때문에 마지막 프로세스에서 나와서 롤백을 하더라도 의미가 없음.     
즉, DB 트랜잭션이 짧게 일어남. 이 짧은 트랜잭션들을 하나로 묶는 것이 SAP 트랜잭션 - ABAP 트랜잭션임 : 짧은 트랜잭션이 아니라 마치 유저가 하나로 연결하여 사용하는 느낌임.     


### Lock Management in AS ABAP 시스템

`Enqueue 프로세스에 관련된 내용`

Enqueue가 있는 것은 Central Instance임.   
따라서 Abap 메시지 서버로 요청을 날리면 인큐 서버로 가서 락 엔트리를 잡고,     
Lock Table에 지금 현재 다른 유저가 해당 테이블을 쓰고 있다는 정보를 기입해놓음.   
이를 통해 다른 유저가 건들지 못하게 함. 다만 조회 접근은 가능함.

`The Principle of Asynchronous Update`

동기화 업데이트 규칙 
화면이 여러개가 있으면서 업데이트라는 프로그램이 있다고 하면,       
마지막에 저장/취소 버튼을 누른다고 하면 한 번에 원래 저장되고 취소되어야 하지만 SAP의 경우 각각 짧은 프로세스마다 반영이 되므로 이때 취소를 눌러도 롤백할 방법이 없음.
그래서 업데이트 워크 프로세스를 사용하면 이를 할 수 있음.        

업데이트 로그 테이블에 워크프로세스에서 짧게 수행한 로그들을 쌓아놓고 커밋 워크를 만나기 전까지 그대로 있음. 커밋 워크를 만나면 그제서야 그 로그들을 실제로 반영함.

이 짧은 DB 트랜잭션을 하나의 긴 ABAP 트랜잭션으로 묶는 작업이 가능함.

`Asynchronous Updates`

유저가 업데이트 리퀘스트를 계속 날리는데, 다이얼로그 워크프로세스에서 바로 하는 것이 아니라 VB 테이블에 해당 리퀘스트들을 하나 둘씩 쌓아놓음.    
그리고나서 커밋 워크를 만나는 순간 이 때 업데이트 워크 프로세스가 VB 로그 테이블에 있는 모든 내용을 읽어서 VB 테이블에 반영하는 역할을 담당.    

sm50에 들어가면 워크프로세스를 볼 수 있음    
sm12에 들어가면 락 프로세스를 볼 수 있음.     
누가 lock 잡고 있는지 확인 가능. 예를 들어 소스코드 수정의 경우 누가 수정하면 lock이 잡힘.

`Printing in AS ABAP`

Spool 워크 프로세스가 이와 연관되어 있음.      
유저가 프린트 버튼을 눌러 요청하면, 다이얼로그 워크프로세스가 유저의 요청을 받아들여 
프린트에 대한 내용 TemSe라는 곳에다가 저장해 둠.    

쭉 쌓이면 spool 프로세스는 로컬 프린터나 네트워크에 있는 서버에다가 전송하는 역할을 담당함.

`백그라운드 작업을 스케쥴링 하는 방법`

백그라운드 워크 프로세스가 이와 연관되어 있음.   
유저가 특정 프로그램을 언제 실행시키라는 job을 등록함. 
그럼 백그라운드 스케줄러는 유저가 설정한 시간이 되면 그 job을 읽어 백그라운드 프로세스에 요청을 함. 
백그라운드 워크 프로세서는 그 job list를 읽어 데이터베이스에 업데이트를 하는 작업을 수행.
주기적으로 프로그램을 실행해야 되는 경우 혹은 프로그램 수행 시간이 긴 경우, 이 background job을 수행함.


`게이트웨이를 통한 통신`

시스템 간의 통신을 담당.    
서로 다른 시스템 간의 통신을 할 때는 게이트웨이(RFC)를 통해 통신.
또는 외부 시스템(서드파티) / 내부 시스템 통신을 담당할 때도 사용



`ICM`    
웹 브라우저에서 요청이 오면 ICM이 이 요청을 받아     
ABAP 디스패처 혹은 Java 디스패처로 분기하여 데이터를 보내는 역할을 수행함. 

 

 

 