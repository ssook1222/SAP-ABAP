# Unit12 - DATA MODELING과 순회  

## Lesson1. 데이터 모델링 방법 

### 데이터 모델링
실세계의 필요한 내용의 일부를 추출해 데이터 모델을 생성. 이때 ERD로 관계를 정의하고,
이 ERD를 통해 ABAP 딕셔너리에 모델링을 수행.    
모델링한 오브젝트를 관계형 데이터베이스로 구현 가능함.    
앞에서 정의한 관계를 바탕으로 ABAP 딕셔너리에 Transparent table을 정의. 

### Transparents Table의 기술적인 구조 

Transparent table은 딕셔너리에 정의함.    
Transparent table과 정확히 1대 1로 매핑되는 테이블이 실제로 데이터베이스 레이어에 존재함.   
데이터베이스 레이어에 존재하는 테이블이 실제로 콘텐츠를 가지고 있음.    
Transparent table은 이 데이터베이스 테이블에 대한 정의만 가지고 있음, 그래서 시스템에서 직접 접근이 불가능함.     
모든 데이터베이스 오브젝트는 딕셔너리에 생성하면 딕셔너리에 생성된 오브젝트를 활성화하는 순간, 자동으로 데이터베이스 레이어에 만들어짐.     

Transparent table을 만들려면 Transparent table의 어떠한 필드끼리 조합을 해줘야 하는데 
이 필드는 Data Element를 기반으로 만들어진 것임.    
Data Element는 딕셔너리에서 정의할 수 있는 데이터 타입 중 하나임.    
그리고 Data Element는 다시 Domain을 참조함.

즉, 데이터 타입이나 지정할 수 있는 변수길이에 대한 정보를 도메인에서 정의하고 여기서 정의한 정보를 Data Element에서 사용함. Data Element는 의미론적인 정보를 가지고 있음.     
Data Element를 실제로 Transparent table의 필드가 사용함. 
SE11번에서 Transparent table을 조회 가능함.    
Transparent table은 데이터베이스 테이블을 정의하기 때문에 실제 키 값이 어떤 것인지 이에 대한 정보를 줘야 함.   
Transparent table의 기술적인 세팅이나 인덱스 역시 Transparent table 생성하는 곳에서 조회할 수 있음. 

### Transparent table을 만들 때 추가적으로 입력해야 되는 정보
#### 키필드
- 기술적인 정의 : 사전 지정 범위 및 접근 빈도수     
  세컨더리 인덱스와 버퍼링 관련 정보를 정의할 수 있음.    

데이터베이스 테이블 내에 스트럭처를 참조하는 것은 존재하지 않음!
스트럭쳐에서는 개별 필드를 컴포넌트라고 하고, Transparent table에서는 개별 필드를 필드라고 부름.
Transparent table을 ABAP 딕셔너리 입장에서 바라보았을 때 Transparent table을 타입으로 지정해서 데이터 오브젝트를 만들 경우, 
해당 오브젝트는 스트럭쳐 타입 오브젝트가 됨. 

> 절대 인터널 테이블이 되는 것이 아님!!!!!!!!!!!!!!!!!!!!! 

Transparent table은 실제로 Transparent table와 대응되는 테이블이 데이터베이스 레이어에 존재함.     
Transparent table 타입으로 데이터 오브젝트를 구현하면 스트럭쳐 형태의 오브젝트가 나오고,
마찬가지로 스트럭쳐 타입으로 데이터 오브젝트를 구현하면 스트럭쳐 형태의 오브젝트가 나온다.   
테이블 타입으로 데이터 오브젝트를 구현하면 테이블 형태의 오브젝트가 나온다. 


## Lesson2. 싱글 데이터베이스 레코드를 취득하는 방법
데이터베이스 인터페이스는 데이터베이스로부터 데이터를 가져올 때 
테이블 버퍼를 사용하여 더 빠른 속도로 데이터베이스의 데이터를 가져올 수 있게 함.   

### 데이터베이스 테이블을 검색하는 방법 
어플리케이션 계층도 이용      
어플리케이션 계층도를 사용하여 어플리케이션을 누른 후, 거기에 속한 컴포넌트를 클릭하여 그 밑의 패키지를 찾아 검색하는 방법. 

### 프로그램을 이용하는 방법
특정 프로그램에서 어떤 데이터베이스가 쓰였는지 알기 위해서는 프로그램에서 문자열 검색을 하는데,
SELECT 문자열 검색을 수행하면 됨.
데이터베이스 테이블은 SELECT으로 나오기 때문임.     
데이터 조회/순회 시 사용하는 컴포넌트들을 보통 Reuse Component(함수모듈, 글로벌 클래스의 메소드, BAPI, 논리적 데이터베이스 - 데이터 가져오는 로직을 미리 프로그래밍 해놓음. 이 로직을 사용해서 데이터를 취득)로 만듦. 

### OPEN SQL의 기본적인 문법 

```

SELECT <Field LIST: 데이터베이스 테이블로부터 어떤 필드를 가져올 것인지 나열 , 컬럼의 양 조절 가능> 
FROM <table : 어떤 데이터베이스 테이블로부터 데이터를 가져올 지 테이블을 정의> 
INTO <target : 데이터베이스 테이블로부터 가져 온 데이터를 어디에 담을지 타겟을 정의> 
WHERE <condition : 실제 데이터베이스 테이블로 데이터를 가져올 때 필요한 데이터를 담기 위해 검색 조건을 줄 수 있음, 행의 개수를 줄일 수 있음.>  

``` 

보통은 가져오는 데이터의 행과 열을 조정해서 가져옴! 

### 싱글 레코드를 반환하는 SELECT문에 대한 설명 

Transparent table로 타입을 선언했으므로 스트럭처 오브젝트가 됨.    
SELECT문을 사용할 때 단지 한 개의 데이터 문만 읽어오겠다고 하면,
SELECT SINGLE 구문을 사용하면 됨.   

SELECT SINGLE 다음 *(Asterisk)를 사용하면 모든 필드를 가져오라는 의미와 동일함.    
SINGLE 한 라인을 썼으므로 INTO 다음 스트럭쳐 타입(한 라인을 차지하는 데이터 구조)이 와야 함.    
이 스트럭쳐 타입의 경우 데이터베이스 테이블 한 라인의 구조와 일치해야 함. 즉, 필드끼리 같아야 함. 

WHERE 조건 절에는 어떤 정보를 들고 오겠다는 정보를 줘야 함.
조회 이후 sub-rc를 사용하여 제대로 데이터를 취득했지 알 수 있는데, 0인 경우 성공했다는 의미임.
따라서 0이 아닌 경우에는 적절한 에러 메시지를 출력해주면 됨.   

SELECT문 이후 필드리스트를 사용하였을 때, 그 다음 Target Area를 어떻게 정의해야 하는가?     
필드리스트를 나열한 것에 대해 데이터를 들고 올텐데 필드리스트 다음의 구조와
INTO절 다음 스트럭쳐의 구조가 같은 타입으로 타깃 영역을 설정해야 함. 

앞의 SELECT 다음에 Field LIST를 나열하였을 때
그 필드 리스트와 정확히 같은 타입의 구조 타입으로 데이터를 받아야 한다는 불편함을 해결하기 위해 새로운 문법이 등장함. 

`INTO CORRESPONDING FIELDS OF 타깃 영역 명` 

굳이 가져온 필드 리스트와 일치하지 않아도 됨.    
갖고 온 필드와 이름이 동일한 열에 대해 값을 복사해 줌.

## LESSON 3. 데이터베이스 레코드로부터 여러 건을 받아서 반환하는 방법 

### SELECT - LOOP 문
해당 SELECT 문을 사용할 때 데이터를 취득하기 위해 한 건마다 루프를 돌게 됨.   
데이터베이스 인터페이스에서 한 건 씩 루프를 돌면서 반환해 줌.   
한 건씩 리턴을 해주기 때문에 스트럭쳐 타입으로 받았음. 

SELECT - LOOP는 데이터 건 수만큼 루프를 돌게 되어 있음.    
루프를 돌면서 수행할 선언문을 나열해주면 됨. 

여러 건의 데이터를 가져오며, 데이터베이스 인터페이스에서 그 건에 해당하는 루프를 돌면서 한 건씩 반환을 해주기 때문에   
타깃 영역의 스트럭쳐 타입 오브젝트로 가져오면 됨.      
Sy-dbcnt는 총 몇 건의 데이터를 가져왔는지에 대한 정보가 들어 있음.     
Array fetch를 사용하여 여러 건의 데이터를 취득하는 방법 

타깃이 TABLE이므로 인터널 테이블 형식이어야 함.    
그리고 인터널 테이블 형식으로 데이터를 가져올 경우 END SELECT 구문이 없음!    

데이터베이스에 있는 여러 레코드들은 데이터베이스 인터페이스에서 올려 사용.   
데이터베이스 인터페이스에서 갖고 온 데이터를 한 번에 프로그램에 던져줌.    
그렇기에 인터널 테이블로 받아야 함. 


## LESSON4. 데이터베이스 접근의 다른 관점
### 클라이언트 특정 테이블(Client Specific Table)로부터 데이터를 취득하는 방법
테이블이 클라이언트 별로 관리하고 있음.     
- Client Specific Table : 테이블의 첫번째 키 컬럼이 클라이언트 별로 관리되는 것을 Client Specific Table이라고 부름.    
이런 Client Specific Table로부터 데이터를 가져올 때에는, 2가지 케이스로 조회문을 사용 가능함.    
조회문을 날리기 전에 현재 내가 로그온한 클라이언트 넘버를 파악해야 함.    
조건이 없으면 로그온한 클라이언트 넘버에 해당하는 데이터만 가져옴.    
로그온한 클라이언트가 아닌 특정 클라이언트의 데이터를 가져오고 싶다면,   
`CLIENT SPECIFIED + 조건(where)` 절에다가 클라이언트 값을 넣어주면 됨.   
`CLIENT SPECIFIED`를 쓰면 꼭 조건 절에 클라이언트 넘버를 넣어줘야 함.   
안 넣으면 모든 클라이언트에 해당하는 데이터를 가져옴. 즉, 아무런 의미가 없어짐. 
  
### 키 필드가 아닌 것을 통해 접근할 때 
키 필드에 해당하는 것은 자동으로 primary가 붙어 있음.     
즉 키 필드가 아닌 것은 인덱스가 없음. 다시 말하면 목차가 없음.    
따라서 해당 필드에 있는 값을 전부 찾아야만 함. 블록 단위 검색도 불가.    
당연히 속도가 느려짐.    
따라서 이 방법은 지양해야 함. 

그래서 세컨더리 인덱스를 만들어서 사용해야 함.       
세컨더리 인덱스를 사용하면 키 필드가 아닌 필드를 인덱스에 등록하는 것과 같은 의미임.     
그래서 그 목차를 통해 접근을 하므로, 전부 찾지 않고 해당 행으로 바로 접근하기 때문에 속도가 안 쓸 때보다 빨라짐. 

### SAP 테이블 버퍼
SAP 테이블 버퍼는 어플리케이션 서버 레벨에 존재함.    
데이터베이스 인터페이스가 조회문이 만나면, 해당 결과가 버퍼에 있으면 버퍼에서 찾아서 리턴함!    
그래서 시간을 단축할 수 있음. 없는 데이터면 데이터베이스에서 값을 찾아 버퍼에 값을 쌓아 둠.    
테이블 버퍼를 사용가능하게 하는 것이 데이터베이스 인터페이스임.
데이터베이스 프로그램 검색 속도를 높일 수 있는 방법은 세컨더리 인덱스와 테이블 버퍼를 사용하는 것임.   

### 테이블 조인
여러 테이블의 산재된 정보를 마치 하나의 테이블처럼 보여줘야 할 때, 조인이 필요.
테이블을 조인할 때 필요한 entry들 어떤 테이블을 정의할 지 - JOIN TABLES    
어떤 조건으로 연결시킬 것인지 - JOIN CONDITION    
각각의 테이블에서 사용할 칼럼이 무엇인지 - JOIN COLUMNS     

이렇게 3가지가 조인 시 필요한 특성들임.   

### 테이블 조인을 구현하는 옵션
테이블 조인하기 위해 2가지 방법이 있음. 

-  데이터베이스 뷰 사용방법    
딕셔너리에 만들어서 사용.    
조인을 미리 구현해놓는 방법임.    
여러 테이블로부터 조인 정보를 미리 뷰로 만들어서 사용.    
실제로는 이 뷰를 테이블처럼 사용하면 됨.
 
- ABAP JOIN 사용방법    
프로그램 내 필요한 곳에서 직접 조인을 구현.   
조회한 다음 이너 조인하는데, 조인 조건을 걸어두면 됨.
두 개 다 속도는 동일함.    
1로 하는 이유는 한 번 만들어 놓은 곳을 재사용해서 사용 가능하기 때문. 
  
- 데이터베이스에 값을 변경할 수 있는 접근 권한     
조회문은 값을 취득할 때 사용,  

- INSERT / UPDATE / DELETE / MODIFY(데이터 조작어)는 데이터베이스의 값을 변경할 때 사용. 

## LESSON5. 권한 확인 

`권한 콘셉트`    
SAP 시스템 안에는 오브젝트 클래스들이 있고, 오브젝트 클래스 안에는 권한 오브젝트들이 존재함.    
이 권한 오브젝트를 가지고 권한을 생성하고 생성된 권한을 프로파일에 할당함.
할당된 프로파일로 다시 역할을 만들고, 이 롤을 유저에게 할당하면 그 유저에 대한 권한이 적용됨.   
이 권한은 데이터베이스에 접근할 수 있는지의 여부를 확인 가능함. 

`권한 확인`
셀렉션 스크린에서 LH를 입력하고 액션을 취하면, 프로그램에서 권한을 확인함.    
권한을 확인할 때에는 유저 마스터 레코드에서 프로파일을 읽어 현재 유저에게 할당된 권한을 읽음.    
핸들링할 수 있는 권한이 있으면 sub-rc가 0임.   
프로그램에서 이런 식으로 권한 체크를 해줘야 함. 

`권한 설정 화면`    
권한 필드를 설정해줘야 함.

`권한 체크 문법`   
자동으로 템플릿을 만들 수 있음.    
필드만 매핑하게 만들 수 있음.   
그러나 이 기능을 잘 사용하진 않음. 
