# Unit15 - 프로그램 호출과 메모리 관리 
## LESSON1. 동기적으로 프로그램을 호출하는 방법
### 동기적으로 프로그램을 호출하는 법
프로그램에서 프로그램을 호출하는 방법은 2가지가 있음. 

`insert 방식`    
프로그램 1이 실행되다가 프로그램2가 실행되면 프로그램2가 끝날 때까지 1이 기다렸다가 2가 끝나면,   
프로그램1이 마저 실행되는 형태. 프로그램 사이에 프로그램이 실행되는 형태임. 

`New start 방식 `  
프로그램1이 실행되다가 프로그램1이 멈추고 프로그램2가 계속 쭉 실행됨.    
`리포트 프로그램 호출하는 방법 `
프로그램에서 리포트 프로그램을 호출할 때에는 submit이라는 키워드를 사용해야 함.       
```abap
Submit 리포트 프로그램 이름 
```

Submit과 submit and return이 있음.    
Submit은 new start 방식     
프로그램2가 끝나버리면, 프로그램1로 돌아가지 않고 (즉, 프로그램 자체가 종료) easy access 화면으로 돌아감.    
submit and return는 insert 기법을 기반으로 프로그램을 호출.     
프로그램2가 실행되고 리스트가 출력되어 프로그램2가 끝나면 프로그램 자체가 끝나는 것이 아니라     
프로그램2를 호출한 곳(프로그램1)으로 이동.     
submit and return에 via selection screen이라는 옵션을 주면,
그림처럼 프로그램2가 실행되며, 프로그램 2에 있는 selection screen을 보여줌.     
1,2는 via selection screen이 없기 때문에 바로 리스트를 출력해주지만 하단의 경우 via selection screen 옵션이 있으므로
해당 셀렉션 스크린을 보여주는 형태임.      
프로그램과 프로그램을 호출할 때 데이터를 넘겨줄 수 있음.      
만약 프로그램1과 2가 있을 때, 2에서는 셀렉션 스크린이 있음. 그 셀렉션 스크린에 나타날 디폴트 값을 프로그램1에서 미리 정의해 줄 수 있음.
그 방법은 아래와 같음.    
``` abap
SUBMIT 값을 넘겨 줄 프로그램명
WITH 필드 이름과 값. 
```
 

### 리포트 프로그램 호출 시 파라미터를 넘겨주는 방법
호출하는 프로그램의 셀렉션 스크린에 파라미터가 있을 경우, 파라미터 이름과 밸류 값을 넣어주면 됨.    
셀렉트 옵션이 있으면, 셀렉트 옵션 넣어주고 그 밸류 값과 함께 INCLUDE인지, EXCLUDE인지 넣어줘야 함. 또 범위도 받을 수 있음.    
아니면 RANGE 테이블(셀렉트 옵션 생성 시 만들어지는 인터널 테이블)도 넘겨줄 수 있음.    
RANGE 변수를 선언하는 방법은 아래와 같음.

```abap
DATA SET { TYPE | LIKE } RANGE OF {TYPE | DATA-OBJECT }
```

해당 테이블의 범위를 담을 수 있는 RANGE 테이블이 하나 선언됨.    
프로그램 호출하는 것을 만들 때에도 패턴 기능을 사용하면 쉽게 만들 수 있음.   

### 트랜잭션 코드가 있는 경우 트랜잭션을 호출하는 방법
프로그램에서 트랜잭션 코드를 호출하는 방법은 두 가지가 있음     
`LEAVE TO TRANSACTION` : new start 방식
프로그램1이 끝나고 프로그램2가 실행됨.     
프로그램2에서 종료하는 구문을 만나면 프로그램1이 없으므로 1이 최초에 실행된 곳으로 돌아감.     
프로그램1에서 리부트 트랜잭션을 날리는 순간에 프로그램 자체는 종료되고 프로그램2가 실행됨.

`CALL TO TRANSACTION` : insert 방식      
트랜잭션 코드가 가리키고 있는 프로그램2가 실행.    
프로그램2에서 뭔가 끝나는 조건을 만나면 프로그램1로 다시 돌아옴. 

### 프로그램에서 트랜잭션을 호출할 때, 데이터를 넘겨주는 방법
인터널 테이블을 사용하여 해당 트랜잭션으로 데이터를 넘겨주는 예제.     
스크린의 정보를 그대로 담은 데이터(gt_bdcdata). : 인풋 값, 어떤 버튼이 눌렸는지 그대로 정보를 인터널 테이블에 담음.      
해당 정보를 담아서 트랜잭션 코드 이동 시 해당 값들을 다 넘겨줄 수 있음! 

### BDC 인터널 테이블에 대한 설명
BDC 데이터 구조는 프로그램, 필드 네임, 필드 값, dynpro, dynbegin으로 만들어진 인터널 테이블임.
프로그램에는 프로그램 이름이 들어감.     
Dynpro에는 실제로 처리하는 화면 번호가 들어감.   
Dynbegin에는 화면 시작의 x 값이 들어감.      
필드 네임에는 화면에 있는 필드 이름이 들어감.         
필드 값에는 그 필드에 들어가는 값이 들어감.    
Bdc_okcode는 화면에서 어떤 유저가 어떤 액션을 했는지에 대한 정보를 담을 수 있음.    
화면에서 입력되는 값과 액션들을 그대로 인터널 테이블에 담아놓은 것임.    
트랜잭션 호출 시 이 BDC 데이터를 넣으면 트랜잭션이 실행되면서 그 인터널 테이블에 있는 내용을 분석 처리하여 실행이 됨. 

## LESSON 2. ABAP 런타임과 메모리 관리 

### 프로그램 개발 버전
활성화된 개발 버전 전제이며, R/3 레포지토리에 소스코드가 저장됨.    
개발 버전이 이 곳(R/3 레포지토리)에 저장됨.    
따라서 ABAP 프로그램은 소스코드, 스크린, 텍스트, 인터페이스로 구성되어 있음.    
그래서 에디터에서 소스코드를 수정하기 위해 화면에 프로그램을 디스플레이함. 

### 프로그램의 GENERATED VERSION
GENERATED VERSION은 개발 버전과 연결되어 있는데 프로그램이 실행되면 GENERATED VERSION이 실행됨.    
GENERATED VERSION은 컴파일된 소스코드라고 생각하면 됨.    
이미 한 번 실행되었을 경우, 수정하지 않는 이상 GENERATED VERSION은 더 이상 생성되지 않음.    
기존 생성된 GENERATED VERSION을 사용함. GENERATED VERSION을 사용하여 런타임 시스템에 프로그램의 정보가 담긴 오브젝트를 만들어 놓음.     
소스코드나 딕셔너리 내에 있는 오브젝트 등이 수정될 경우 GENERATED VERSION은 재생성됨. 

### 프로그램 활성화 시 발생하는 일
활성화 버전의 소스를 에디터로 열어 소스 코드와 스크린을 수정함.    
툴 영역에 있는 모든 오브젝트들을 저장함. 저장할 때에 비활성화 오브젝트가 생성됨.    
생성된 오브젝트에 대해 문법 체크를 함.    
문법 상태에 아무런 문제가 없으면 비활성화 상태의 오브젝트를 활성화 상태로 바꿈    
그 후 활성화 버전에 덮어 씌움.   
최종적으로 GENERATED VERSION이 다시 생성됨.    
소스코드가 수정되었으므로 컴파일이 되어야 함.   
컴파일에는 GENERATED VERSION이 다시 생김. 

### PXA와 ROLL AREA
프로그램이 실행되면 GENERATED VERSION을 읽어서 어플리케이션 서버에 워킹 메모리에 필요한 공간을 할당.     
프로그램에는 수정 가능한 부분과 수정 불가한 부분이 있음. 
후자의 경우 바이트 - 소스 코드, 상수, 문자열, 프로그램 텍스트, 화면 정의 같이 변화 없는 정보임. 전자는 프로그램에서 사용하는 변수들임. 

### PXA
변하지 않는 정보 (수정 불가능한 정보)가 이 영역에 저장됨.    
프로그램 당 1번만 저장됨.    
메모리 낭비를 최소화하기 위해 사용

### ROLL AREA
변하는 정보가 저장됨.    
실행할 때마다 변화하므로 유저당 매 번 저장함.    
ROLL IN과 ROLL OUT이 ROLL AREA에서 진행됨.    
데이터를 안 쪽으로 가져와서 덮어씌우면 IN, 내보내면 OUT임. 

### 논리적 메모리 모델
SAP 시스템의 메모리 구조에 대한 설명     
외부, 내부 세션이 존재.    
외부 세션 : GUI 창의 개수 = 외부 세션의 개수     
하나의 외부 세션 안에는 총 9개의 내부 세션이 있음.      
내부세션은 SUBMIT이나 CALL 트랜잭션을 하는 경우, 내부세션이 한 개씩 생성됨.    
메모리 구조 안에 데이터를 공유할 수 있는 곳이 ABAP 메모리, SAP 메모리 총 2개임.
SAP 메모리안에 데이터를 저장해 놓으면 외부 세션과 내부 세션을 공유하여 전부 사용 가능함.    
ABAP 메모리의 경우 외부 세션 안에 있기 때문에 내부 세션들끼리만 공유 가능하며, 다른 외부 세션에서는 사용 불가 

### 프로그램 그룹
하나의 내부 세션을 보면, 내부 세션 안에는 메인 프로그램 그룹과 추가적인 프로그램 그룹이 존재.   
메인 프로그램 그룹에는 메인 프로그램이 로드됨.    
메인 프로그램 내의 모듈화 유닛을 호출하면 해당 모듈화 유닛을 포함하는 함수 그룹이 추가적인 프로그램 그룹으로 로드됨. 

### 프로그램 호출 - 삽입 방식
하나의 내부 세션에서 프로그램이 돌고 있음. 그리고 프로그램1에서 프로그램2를 호출하면,    
프로그램1은 그대로 존재하고 프로그램2를 담는 내부 세션이 추가적으로 생성됨.     
그리고 프로그램2가 종료되면 프로그램2를 담는 내부 세션은 사라지고 다시 프로그램1 내부 세션으로 돌아옴.     

### 프로그램에서 프로그램을 호출 시 - 새로운 시작(NEW START) 방식
REPORT로 NEW START(SUBMIT) 하는 방식과 LEAVE TO TRANSCATION 방식이 다름. 

`REPORT로 NEW START(SUBMIT)하는 방식 `    
내부 세션이 3개가 있고, 3번째 세션에서 프로그램3이 실행되고 있음.    
ABAP 메모리가 그대로 있음.    
프로그램3이 진행되고 있었는데 프로그램 3에서 SUBMIT으로 프로그램4를 호출하는 순간에
프로그램3을 담고 있는 내부 세션이 초기화되고, 프로그램4가 대체되는 형식.     
프로그램3은 프로그램이 종료되면 없는데, ABAP 메모리에 그대로 프로그램3 데이터가 남아 있음.  

`REPORT로 LEAVE TO TRANSCATION 하는 방식 `

최초 실행방식은 동일, 프로그램3이 내부 세션에서 있음. 프로그램3에서 LEAVE TO TRANSCATION을 날리면,
현재 외부 세션 안에 있는 내부 세션을 초기화 시켜 없앤 후 트랜잭션을 호출한 프로그램이 실행됨.     
ABAP 메모리도 초기화함. LEAVE TO TRANSCATION을 쓰면 외부 세션 안에 있는 내부 세션 모두 종료하고,
호출한 내부 세션 안에 프로그램이 하나 생겨남.    
트랜잭션이 실행되는 순간에 ABAP 메모리도 초기화하므로, 메모리 내부에 있는 데이터도 사용 불가능함.  

### 메인 프로그램 그룹과 Additional Program Group
하나의 내부 세션, 내부 세션이라고 보면 해당 세션에는 메인 프로그램 그룹과 Additional Program 그룹이 있음.    
메인 프로그램에는 메인 프로그램이 흐르고, Additional Program 그룹에서는 글로벌 모듈 유닛(함수 그룹, 글로벌 클래스)이 호출했을 때 자리 잡음.    
메인 프로그램에서는 메인 프로그램 만의 글로벌 데이터 오브젝트가 자리 잡고 있음.     
Additional Program 그룹에서는 글로벌 데이터 오브젝트나 함수 그룹과 같은 내용을 저장하는 곳이 자리잡고 있음. 

### 서로 다른 내부 세션에서 동일한 함수 그룹을 사용할 경우 메모리 구조
최초 내부 세션에서는 메인 프로그램에서 함수 그룹 XY에 있는 함수 모듈을 호출해서 Additional Program 그룹에 함수 그룹 XY를
올린 상태임.    
그 이후에 메인 프로그램에서 submit 키워드를 사용하여 메인 프로그램2를 inserting 기법으로 호출함.    
그러면 내부 세션이 생겨나고 메인 프로그램 그룹이 자리 잡고 메인 프로그램2가 로드 됨.    
이때 메인 프로그램2에서 함수 그룹xy의 요소를 호출했다고 하면, 이 때는 함수 그룹 xy의 요소를 메인 프로그램2를 동작시키고 있는 내부세션에 다시 로드함.    
즉, 각각의 내부 세션에서 함수 그룹 xy를 호출했다고 볼 수 있음. 이때 글로벌 데이터 오브젝트도 같이 호출되는데, 그 호출된 장소가 다름. 다시 말하면 서로 다른 내부 세션에서 호출된 글로벌 데이터 오브젝트들은 서로 데이터의 내용을 공유하지 않음. 

### 서로 다른 내부세션에서 동일한 클래스를 사용할 경우 메모리 구조
최초 내부 세션에서는 메인 프로그램에서 클래스에 있는 메소드를 호출하였음.   
글로벌 클래스가 Additional Program 그룹 영역에 호출됨.     
메인 프로그램1에서 메인 프로그램2를 submit 키워드를 사용하여 내부 세션을 하나 더 생성하고,    
메인 프로그램2를 inserting 기법으로 호출함. 이 안에서 글로벌 클래스를 호출하면 글로벌 클래스가 또 다른 내부 세션에 로딩됨.    

### 한 내부 세션 내에서 같은 함수 그룹에 있는 모듈을 여러 번 호출했을 경우에 그 그룹이 로드되는 과정
메인 프로그램에서 함수 그룹 ab에 있는 특정 모듈을 호출함. 그 함수 그룹이 로드됨. 그 함수 모듈에서 함수 그룹 xy에 있는 어떤 모듈을 호출함.    
그렇게 되면, 그 함수 그룹이 로드됨.    
메인 프로그램에서 함수 그룹 xy에 있는 어떤 모듈을 호출함.    
그런데 이미 해당 함수 그룹은 로드가 되어 있으니 로드를 안 함.    
한 내부 세션 내에서 함수 그룹을 로드하면, 아무리 호출당해도 재 로드를 하지 않음. 

### 서브루틴을 호출했을 때의 메모리 구조
서브루틴은 서브루틴을 모아두는 풀을 만들 수 있음.     
서브루틴 풀에 있는 서브루틴을 메인 프로그램에서 호출했을 때 그 때 메모리의 구조는 아래와 같음.     
서브루틴 같은 경우, 서브루틴을 호출하면 해당 서브루틴 데이터를 Additional Program 그룹 영역에 로드하는 것이 아니라    
자신의 메인 프로그램 그룹에 서브 루틴 풀 자체를 로드해 버림.    
메인 프로그램 안에서 서브 루틴 안에 정의되어 있는 데이터들을 가져다가 사용 가능함.    
메인 프로그램 안에 정의된 데이터 모두 가져다가 쓸 수 있음. → 하나의 프로그램처럼 사용할 수 있다는 의미. 

### 프로그램과 프로그램을 호출할 때 데이터를 전송하는 방법
`Sap 메모리, abap 메모리 `
프로그램 a에서 프로그램 b를 호출할 때 sap/abap 메모리에 값을 적어 놓고 프로그램 b에서 이 값을 읽어와서 프로그램을 실행시킬 수 있음.    
- Sap 메모리 사용
- abap 메모리 사용
- 인터페이스 사용
- DB 사용
- 파일 사용 

### sap/abap 메모리 사용 범위
Sap 메모리의 경우 상당히 그 범위가 넓음    
abap 메모리는 그 범위가 상대적으로 좁은 편임.    
sap 메모리에 어떤 데이터를 저장하면, 내부 세션들에서 해당 메모리로 전부 접근이 가능함.    
외부 세션끼리도 데이터를 공유해서 받을 수 있음.    
abap 메모리의 경우, 한 외부 세션 내에 있는 내부 세션들끼리만 그 데이터를 공유해서 사용 가능.    
다른 외부 세션 내의 내부 세션은 해당 메모리에 접근 불가.    
그러나 abap 메모리에서 leave to transaction이라는 키워드를 썼을 경우에는 해당 메모리가 초기화되므로 사용 불가능함.    

### abap 메모리를 사용하여 프로그램과 프로그램 호출 시 데이터를 주고 받는 방법    
좌측이 abap 메모리, abap 메모리에 프로그램의 데이터를 어떻게 쓰고 읽는지를 확인
내부 세션1에서 돌고 있는 프로그램에 대해 abap 메모리에 데이터를 쓰기 위해서는
`EXPORT 키워드를 쓰고 wa_fli From 특정변수`   
: 특정 변수에 있는 값을 wa_fli에 저장.   
It_spfli라고 하고 as를 안 하면, alias 없이 변수 그대로의 이름으로 저장됨.    
어느 메모리 id에 저장할 것인지 to memory id 키워드와 함께 메모리 id 값을 지정해줘야 함.    
그 다음 다른 세션으로부터 메모리 데이터를 읽어올 때에는,    
Import 키워드를 사용하고, 앞의 세션에서 wa_fli라는 alias를 사용하였으므로 해당 구문에도 이를 지정하여 저장해야 함.   
쓸 때의 메모리 아이디와 읽을 때의 메모리 아이디가 동일해야 함.      

### SAP 메모리를 사용하여 파라미터 전달하는 방법
프로그램 a에서 sap 메모리의 데이터를 사용 중      
`Set_parameter_id`라는 키워드를 사용하면 sap 메모리의 위의 데이터를 사용 가능함.    
Call transaction을 사용하여 다른 프로그램을 호출함.   
Call transaction을 통해 호출되는 프로그램 B에서는 sap 메모리에서부터 데이터를 읽어와야 함.      
그 때는   `Get_parameter_id`  키워드를 사용하면 됨.     
Get_parameter_id를 사용한 다음에 id 값을 적어주고 읽어 온 데이터를 어느 필드에 저장할 지 그 필드를 나열하면 됨. 

### Flat Data Object에서 메모리 관리하는 방법
Flat Data Object : 데이터 길이가 정해져 있는 오브젝트     
선언할 때 데이터 길이가 정해져있기 때문에, 만약 값을 변수에 할당 시 데이터 길이보다 더 적은 값을 넣는다면     
적은 값은 공란으로 비워두고 할당한 그 값만 넣어주면 됨.       
정해진 데이터 길이만큼의 값을 할당하면 이전에 할당했던 값들은 지워지고 새로 할당한 값이 해당 오브젝트에 들어감.        
클리어 하는 순간, 해당 메모리에 있는 내용을 초기화함.      

### String에 대한 메모리 관리
단순 선언만 한다고 메모리를 해당 변수에 할당하지는 않음    
해당 변수에 값을 할당하는 순간에 헤더 정보가 생기고, 헤더가 실제로 해당 정보를 담은 데이터 오브젝트를 가리키고 있음.    
값을 재할당하면 데이터 영역에 값이 재할당되며, 헤더 역시 데이터 영역을 새로 가리키게 됨.     
변수를 클리어하는 순간, 헤더는 그대로이고 헤더가 가리키던 데이터 오브젝트 영역만 사라지게 됨.     
헤더는 아무것도 가리키지 않음. 


### 인터널테이블의 메모리 관리
인터널테이블을 선언하면, 참조 변수가 같이 선언됨.    
그래서 openSQL를 사용하여 인터넬 테이블의 데이터를 채우면 참조 변수가 헤더를 포인팅하고 실제로 읽어온 데이터를 가리키는
메모리 구조로 자리 잡음.     
그래서 내부 테이블에 append 문법을 적용하면 기존에 읽어온 데이터가 있고, 그 옆에 새로 붙인 데이터가 있는 상태임.    
헤더는 해당 인터널 테이블이 어디부터 어디까지 정보이라는 데이터를 담고 있음.     

클리어를 만나는 순간에는 실제로 데이터 초기화하여 없애 버리고 가지고 있음.    
Free하는 순간 헤더 정보 마저도 없애버림.     

### 다이나믹 데이터 오브젝트(인터널 테이블 같이 데이터 사이즈가 정해져있지 않은 것들)를 복사할 때의 메모리 관리
다이나믹 데이터 오브젝트를 복사할 때, 해당 오브젝트들이 차지하는 메모리를 어떻게 관리하는지에 대해 다루고 있음.   
다이나믹 데이터 오브젝트 선언 시 참조 변수도 같이 생성됨.   
첫번째 오브젝트에 값을 할당하면 헤더가 생기고, 데이터도 같이 생김.    
두번째 오브젝트에 첫번째 오브젝트를 할당하면 두번째 레퍼런스 변수가 복사되어 첫번째 레퍼런스 변수가 가리키는 오브젝트를 포인팅하는
방식으로 됨. 실제로 데이터를 만들지 않고 공유해서 사용.     
둘 중 하나의 오브젝트에 변경이 가해지면, 그제서야 데이터를 카피하여 오브젝트를 만들고 포인팅하도록 함. 


### 인터널 테이블 복사 시 메모리 구조
인터널 테이블 2개 선언, 그 후 하나의 테이블에 값을 할당하면 헤더가 생기고, 데이터도 같이 생김.     
다른 테이블에 첫번째 테이블의 값을 할당하면 두 번째 인터널 테이블의 값이 복사되어 첫 번째 인터널 테이블의 헤더가 가리키는
테이블을 포인팅하는 방식이 됨.
이 역시 위와 마찬가지로 테이블 내의 데이터 오브젝트를 만들지 않고 공유하여 사용함.     
그러다가 둘 중 하나의 테이블에 변경이 가해지면, 그제서야 테이블을 복사하여 오브젝트를 만고 포인팅하도록 함. 

### Boxed Components 사이에서의 첫 할당 값 공유
프로그램 구현하다보면, structure와 internal table을 많이 사용함.    
structure와 internal table에는 많은 필드들이 존재함.    
이 중에서 실제 사용하는 필드는 몇 개 없을수도 있음.    
이럴 경우에는 사용하지 않는 필드를 Boxed Component(PXA)에 지정하여 이 영역에 inital value를 참조하게 만들 수 있음.    
이를 통해 메모리 낭비를 줄일 수 있음.    
즉, 사용하지 않는 필드가 있는 경우 이를 다 메모리 영역에 구현해놓는 것이 아니라 Boxed Component(PXA)를 가리키게 하여 일부러 구현하지 않고 메모리 낭비를 줄이는 방식으로 만들어짐.     
값을 할당하면 레퍼런스 관계가 끊어지고, 실제 값을 할당한 데이터 영역을 가리키게 함.    

### 일시적인 값을 Boxed Component로 정의하기
로컬 스트럭쳐 타입 하나 선언함.    
클래스 안에서 속성을 정의하는데, 구조체에 boxed라는 키워드를 붙여줌.    
속성 안에 있는 데이터가 실제 메모리에 잡히는 것이 아니라 PXA에 하나를 잡아놓고 initial value를 넣어 놓음.     
즉, PXA에 초기 값을 참조하고 있는 구조가 됨.    
역시 마찬가지로 값을 할당하는 순간에 참조하고 있던 그 관계는 끊어지고    
실제로 메모리에 데이터 오브젝트가 잡히고 데이터 오브젝트에 값이 들어감.
그 데이터 오브젝트를 포인팅하는 그런 관계가 됨.    

### 인터널 테이블에서 Boxed Component가 어떻게 작동하는가
위에서 Boxed Component로 선언해준 것을 실제로 할당해준다면,    
알맞은 메모리 크기에 맞춰 스스로 메모리 영역이 할당됨.    
위에서 선언한 값이 아니라 Boxed Component(PXA) 영역에 초기 값을 하나 만들어 놓고 전부 참조하는 그런 형태가 됨.    
이렇게 되면 당연히 메모리를 줄일 수 있음. 참조하는 변수 사이즈는 8 바이트임.    
만약에 참조하고 있지 않다면, 이 안에 있는 메모리를 선언한대로 잡아야 하는데 이는 8 바이트를 넘어감.    
메모리 낭비를 줄일 수 있음.