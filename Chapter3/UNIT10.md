# Unit10 - ABAP 내 모듈화 기술 - 서브 루틴, 함수 모듈(그룹), 클래스

### 모듈화 사용 여부
모듈화를 사용할 지, 안 할지는 옵션 사항임.   
필요할 때에는 꼭 사용한다고 생각.    
좌측은 모듈화를 사용 X, 우측은 사용한 케이스임.   
모듈화를 쓰면 가독성이 훨씬 좋음. 유지보수가 훨씬 쉬움.

### Local 프로그램 모듈화

크게 두 가지가 있음.
- 서브루틴
- 로컬 클래스의 메소드       

로컬 모듈화 유닛은 프로그램에서 내부에서 선언하는 유닛, 선언된 프로그램에서 밖에 사용 불가.
프로그램 B에서 만든 로컬 모듈화 유닛을 프로그램 A에서 사용 불가능함.

### 글로벌 모듈화

글로벌 모듈화의 경우 함수 그룹의 함수 모듈과 글로벌 클래스의 메소드가 있음.    
함수 그룹과 글로벌 클래스를 묶어서 전역으로 생성해놓으면,    
시스템에 있는 모든 프로그램에서 함수 모듈과 메소드를 할 수 있음.

### 데이터 캡슐화
모든 프로그램이 자기 자신만의 데이터 오브젝트를 가지고 있다고 가정할 때, 자기자신만의 데이터는 자기자신만 접근할 수 있음.    
함수 그룹 내에 있는 데이터 오브젝트를 프로그램B가 변경했을 경우, 함수 모듈은 누가 언제 자신의 데이터를 변경하였는지 알 수 없음.
또 유효하지 않은 값을 참조할 수도 있음.
서로 다른 프로그램에서는 각자 데이터 오브젝트 외의 다른 데이터를 접근할 수 없게끔 함.    

### Interface와 signature 파라미터를 통한 접근
프로그램에서 타 프로그램 내의 함수 모듈로 접근할 때는 interface를 사용하며,
글로벌 클래스로 접근할 때에는 signature를 사용한다.    
Interface와 signature는 의미론적으로 동일하며, 이들 파라미터를 통해 서로 데이터를 주고 받을 수 있음.
프로그램에서는 함수 모듈을 호출할 때 파라미터를 주고 호출하면, 해당 함수모듈은 파라미터를 받아서 자기 안의 데이터 오브젝트에 접근하여 데이터를 읽거나 쓰는 역할을 수행함.    


### 파라미터의 종류
#### Importing Parameter
모듈화 유닛으로부터 값을 받음 (IN)
#### Exporting Parameter
모듈화 유닛이 외부로 값을 보냄 (OUT)
#### Changing Parameter
모듈화 유닛이 값을 받아서 그 값을 변경하고, 다시 외부로 보내는 파라미터

## Lesson2. 서브루틴 정의 및 호출
### 서브루틴의 가장 간단한 예
메인 프로그램에서 서브루틴 그 자체만 호출하고 있음.
서브루틴을 만들 때에는 FORM 키워드 + 이름을 작성한 후, 그 내부에 로직을 구현하면 됨.
그 후 마지막에 ENDFORM을 작성하면 됨.    

`FORM 서브루틴이름 로직 ENDFORM`    
서브루틴을 호출할 때에는 PERFORM 키워드 다음에 서브루틴 이름을 작성하면 됨.    
글로벌 변수를 사용하여 서브루틴에다가 파라미터를 전달하는 예제
리포트 메인 프로그램에 글로벌 변수를 수행해놓고, 그 서브루틴 안에서 글로벌 변수를 가져다가 쓰는 방식.
당연히 서브루틴은 메인 프로그램 안에 구현되어 있으므로, 당연히 메인 프로그램 내에서 글로벌 변수를 전부 사용할 수 있음.      

서브루틴에 파라미터를 전달
서브루틴을 보면 파라미터 2개를 가지고 있음.     
서브루틴에 정의한 파라미터를 Formal parameter라고 부름.    
프로그램에서 서브루틴으로 데이터를 보낼 때 사용하는 파라미터를 Actual Parameter라고 부름.      

서브루틴 호출 시 파라미터를 넘겨주고, 서브루틴은 그 파라미터를 받아서 연산.
전역변수를 사용해서 로직 구현은 지양, 이 방법은 메인 프로그램의 전역변수를 가져 쓰는데 이건 서브루틴의 재사용성에 위배되는 방식임. 하드코딩과 같은 맥락.
받은 파라미터 값을 가지고 로직 구현하는 것을 지향함.     

### 서브루틴으로 파라미터를 넘기는 방법
총 3가지의 방법이 있음.

- Call By Value : 실제 전역변수 파라미터의 값을 넘겨주는데, 전역변수의 카피본을 서브루틴 F1이 받게 되어 있음.     
서브루틴 F1에서 아무리 값을 변경해봐야 카피본이 변경되므로 실제 전역변수(위 그림에서는 a)에는 아무런 영향이 없음.

- Call By Value and Result : 원본인 복사본을 서브루틴에서 사용함. 만약 이 서브루틴 안에서 에러가 발생하지 않으면 원본 데이터에 복사본을 덮어씌움. 만약 에러가 발생했다면 덮어씌우지 않은 상태로 원본 데이터와 카피본이 따로 있게 됨.

- Call By Reference : 파라미터를 넘길 때 원본 데이터 그 자체를 넘기면 된다고 생각하면 됨.

2는 잘 안 쓰지만, 1번/3번 방법은 잘 기억해둬야 함.

### 서브루틴의 정의와 호출
#### 서브루틴 정의 시 참고해야 될 키워드
- USING : 밖으로부터 값을 받는 IN parameter라고 생각하면 됨. Using + value prefix로 작성
Using value(값)으로 작성할 경우, 이 때 받는 값은 call by value 형태임. 즉 복사본을 받아오는 것임.

- Changing : 서브루틴의 값을 밖으로 빼주는 OUT parameter라고 생각하면 됨. Changing + value prefix로 작성
Changing value(값)으로 작성할 경우, 이 때 보내는 값은 call by value and result 형태임.    
Changing 값으로 작성할 경우, 이 때 보내는 값은 Call by Reference 형태임. : value prefix 없이 사용.
  
#### 서브루틴 호출 시

PERFORM 적은 다음 값을 어떻게 받을지, 받아올지에 따라 서브루틴으로 보낼 경우 USING에,    
값을 서브루틴으로부터 받을 경우 CHANGING에 Value Prefix 없이 알맞은 파라미터를 작성하면 됨.    

### 인터페이스 파라미터 정의 시, 타입 주는 방법

#### Generic Typing
Value prefix 뒤에 TYPE ANY를 붙임.     
ANY 키워드는 어떤 타입이든지 상관없이 전부 받아들일 수 있다는 의미. 타 프로그램에서 사용하는 것과 충돌할 수 있기 때문에 절대 쓰면 안 되는 방식.   
TYPE ANY로 설정하면, 타입의 결정은 프로그램이 시작된 후 진행되면서 이 서브루틴을 호출하는 시점에 결정됨.

### Exact Typing
정의 시 사전에 미리 타입을 지정해두는 방식,     
위의 방식은 타입이 다를 때 연산 충돌나도 어떤 문제인지 파악하기 힘들지만 이 경우는 서브루틴의 파라미터를 정의할 때 미리 지정해두므로, 바로 런타임 에러를 확인 가능함.
따라서 서브루틴 정의 시 사전에 미리 타입을 지정해두자.    

### 글로벌 & 지역 데이터 오브젝트
#### 서브루틴의 데이터 범위
메인 프로그램에서 글로벌 변수 선언하면, 서브루틴에서 해당 변수 접근 가능    
포멀 파라미터는 서브루틴에서만 접근 가능    
서브 루틴 내의 로컬 변수도 서브루틴 안에서만 접근 가능     

### 라운딩을 하기 위해 서브루틴 안에다가 임시변수를 선언한 예제
#### 형변환, 자동형변환과 관련된 내용
- cv_pc : 2자릿수 소수
- lv_pc : 1자릿수 소수
- cv_pc = lv_pc로 값을 할당할 때, 1자릿수 소수지만 2자릿수 소수로 할당되며 자동으로 타입 캐스팅이 진행됨.

### 서브루틴 호출을 빠르게 하는 법
왼쪽에 서브루틴이 보이면 오른쪽에서 사용하고자 하는 부분에 드래그 & 드롭으로 끌어다 놓으면,
템플릿이 자동으로 생성됨. 그 안에 있는 변수들을 바꿔주면 됨.    

### 서브루틴 디버깅 시 확인해볼 내용
- Single step(F5) : 서브루틴 안으로 타고 들어감.
- Execute(F6) : 서브루틴 전체를 한 번에 실행
- 빠져 나올 때는 return(F7) 누르면 됨.
- Call Chain : 서브루틴 내에서 서브루틴을 호출하는 연속적인 방식     
이러한 콜 체인을 확인하기 위해서는 디버깅 시, Standard를 눌러서 확인해보면 됨.
그 콜 체인을 스택 형식으로 확인 가능.     
  
## Lesson3. 함수 모듈 호출

### 함수 그룹
함수 모듈은 함수 그룹에 포함되어 있음.    
기능적으로 관련 있는 함수 모듈들을 모아놓은 그룹이라고 생각하면 됨.    
함수 모듈을 만들기 위해서는 함수 그룹을 생성해야 함.   

### 함수 그룹의 구성
- 글로벌 데이터 오브젝트 : 함수 모듈에서 전부 공유해서 사용 가능
- 서브루틴
- 스크린
함수 그룹을 또 구성하는 여러 개의 함수 모듈이 존재함.
  
### 함수 모듈의 구성
- 속성
- 로컬 데이터 오브젝트
- 소스 코드

______________________________________________________________________________________________ 

### 인터페이스 (함수 모듈의 파라미터)

- Import parameter : 값을 받을 때 사용, 선택사항(optional)으로 설정 가능하며 이렇게 설정된 파라미터는 사용해도 되고 안 해도 됨. 단, 이 파라미터가 optional이 아닌데 사용하지 않을 경우 오류가 발생함.
- Export parameter : 값을 보낼 때 사용, 이 경우는 항상 optional임.
- Changing Parameters : Import와 Export의 혼합임.
- Exceptions : 함수 모듈에서 어떤 에러가 발생하였을 경우에 에러가 발생하였다고, 호출한 곳에다가 알려주는 파라미터로 호출한 곳에서 해당 파라미터를 반드시 처리해줘야 함. 만약 안 했을 경우 런타임 에러가 발생

### 함수 그룹안에 선언된 데이터 오브젝트
함수 그룹 안에 보면 글로벌 데이터 오브젝트가 있지만, 데이터 캡슐화 때문에 프로그램이 바로 해당 데이터 오브젝트에 접근할 수는 없음.
이 데이터에 접근하여 읽거나 새로 작성해야 할 때는 함수 모듈과 그 interface 파라미터를 통해서 값을 넘겨준 다음에      
그 값을 함수 모듈을 통해, 데이터 오브젝트에 접근하여 읽고 쓴 다음 값을 다시 return해줌.      
함수 모듈을 통해 데이터 오브젝트에 접근할 수 있다는 의미임.    

### 함수 모듈의 검색법
함수 모듈을 직접 만들기도 하지만, SAP에서 스탠다드한 함수 모듈을 제공하기도 함.     
그래서 그 함수 모듈을 찾아서 프로그래밍해야 할 일들이 많음.      

### 어플리케이션 계층
어플리케이션 컴포넌트 > 패키지에서 찾고자하는 함수 모듈만을 검색할 수 있음.

### 레파지토리 인포메이션 시스템
SE84번으로 접속하여 오브젝트 타입을 함수 모듈로 한 다음 여러가지 검색 조건을 준 상태로 특정 함수 모듈 검색 가능

### 프로그램 관련 서치
해당 프로그램 안에서 사용된 함수 모듈을 검색하고 싶을 때에는      
(프로그램들이 CALL FUNCTION 모듈을 가지고 시작되어야 하기 때문에
문자열에서 해당 내용을 검색하면 사용된 함수 모듈을 전부 검색 가능함)

함수 모듈 안에서 알고 있는 스크린을 호출할 때, 이 스크린을 어느 함수 모듈에서 호출했는지 찾아보는 방법     
스크린에서 F1키를 눌러서, Technical INFO를 본 다음 그 안에서 스크린 넘버를 더블 클릭 하여
Where-Used List를 누르면 해당 스크린이 어디서 호출되었는지를 확인 가능함.    

### 함수 모듈의 인터페이스를 정의하는 방법

(=SE37번 함수 빌더)
Importing 파라미터를 정의하는 방법, 파라미터 이름 / 타입 / 이 타입이 어떤 파라미터 타입인지 정보를 줘야 함. 이 때 로컬 데이터 타입의 정보를 가져올 수 없으므로 글로벌 데이터 타입이어야 함. /
이 함수 모듈 파라미터의 초기값 / optional 여부 / Pass value : 해당 부분에 체크가 되어 있으면 call by value, 체크가 되어 있지 않으면 Call by Reference임.        

### 함수 모듈 테스트하는 방법    
스탠다드 함수 모듈은 문서화가 잘 되어 있음.    
함수 모듈을 테스트해보고 싶다면 SE37번을 눌러 진행, 함수 모듈이 import parameter를 가지고 있다고 하면,
Import parameter를 넣을 수 있는 화면이 나타남.       
그 값을 넣고 다시 실행 버튼을 누르면 그 결과값이 나타나고, 오류가 나타날 경우 오류도 같이 나타남.

### 함수 모듈을 호출하는 방법

함수 모듈을 호출할 때에는 CALL FUNCTION을 사용하여 호출해야 됨.     
이 때 꼭 ''을 사용해야 됨.      
`CALL FUNCTION '호출할 함수 모듈 이름'`

그 밑으로는 파라미터를 나열하면 됨.     
호출되는 함수 모듈은 Called     
호출하는 곳은 Calling     

호출하는 곳에서의 사용 목적에 맞게 작성.    
함수 모듈로 값을 던져주는 것이기 때문에 EXPORTING이라고 작성,     
함수 모듈로 값을 받는 것이기 때문에 IMPORTING이라고 작성.      
즉, 함수 모듈과 반대로 나열하면 됨.     

### 함수모듈 호출을 빠르게 하는 법

#### 드래그 & 드롭
왼쪽에 서브루틴이 보이면 오른쪽에서 사용하고자 하는 부분에 드래그 & 드롭으로 끌어다 놓으면,
템플릿이 자동으로 생성됨. 그 안에 있는 변수들을 바꿔주면 됨.    
Pattern 눌러서 진행
패턴을 누르면 여러가지 콜 가능.      
호출할 함수의 이름을 적고 확인 버튼을 누르면 템플릿이 자동으로 생성됨     
이 때 변수만 알아서 매핑시켜주면 서브루틴 작성이 끝남.

### Handling Exception
함수 모듈에서 발생하는 예외처리 방법     
함수 모듈을 호출하는 부분에서 예외 처리가 적용되어 있다면,
EXCEPTIONS 키워드를 쓴 후, 나올 수 있는 예외들을 전부 작성해둬야 함.    
`예) EXCEPTIONS 예외1, 예외2.`
위 코드에서 0일 경우 아무 문제가 없는 거지만, 1번/2번인 경우 오류가 발생한 것임.      
이 부분을 처리 안 하면 런타임 오류가 발생함.     
함수 모듈을 조회하려면 se37, 함수 빌더로 가야 함.     
처리를 못할 경우 RAISE 키워드를 사용하여 오류를 일부러 발생시킴.    

## Lesson 4 : Creating Function Modules

### 함수 그룹을 생성하는 방법
오브젝트 네비게이터(=SE80)에서 생성, 오브젝트 타입을 함수 그룹으로 설정한 다음 지정할 이름을 아래에 작성하면 됨.     
없다는 데 새로 생성할 것인지 물어보는 창이 뜨고 그 이후 short description에 그룹과 관련된 설명을 작성하면 됨.    

### 함수 모듈을 만드는 방법
함수 그룹에서 오른쪽 클릭한 다음, CREATE > FUNCTION MODULE을 클릭하면 됨.     
또는 SE37(=function builder)에서도 생성이 가능함.     
함수 모듈 생성 창이 나오면, 함수 모듈 이름을 넣어줘야 하는데 네이밍 룰을 따라 Z나 Y로 반드시 시작해야 됨.     

## Lesson5. Business Application Programming Interfaces(BAPIS)
BAPI를 함수 모듈이라 생각해도 무방

### BOR과 BAPI의 관계
SAP System 내부에는 Business Object Repository(BOR)이라는 시스템이 존재,
그 레포지토리 안에 Business Object와 BAPI가 모두 존재함.     
BAPI는 비즈니스 오브젝트의 상태나 속성을 변경시킬 수 있고, 또 비즈니스 오브젝트를 생성하거나 또 삭제시킬 수 있는 함수.     
비즈니스 오브젝트의 경우 Sales Order를 예로 들 수 있고, BAPI는 Sales Order를 추가/삭제하거나 변경시키는 데 사용할 수 있음.
BAPI는 실제로 함수 프로그램, ABAP 모듈로 구현이 되어 있음.
실제로 BAPI에 있는 내용을 호출하면 데이터베이스 테이블에 있는 내용을 변경하는 식의 흐름이 됨.       

BAPI는 SAP 내부 시스템에서 호출되기도 함.     
그러나 주로 호출하는 시스템은 External System임.
즉, SAP 시스템이 아닌 시스템에서 SAP에 접근하기 위해 사용하는 것이 BAPI임.      

### BAPI 사용처
#### 표준 BAPI
필요에 따라 상황에 맞는 BAPI를 호출하여 사용해야 함.    
- GetList : 오브젝트의 리스트를 반환하는 데에 사용
- GetDetail : 오브젝트의 속성값을 반환하는 데에 사용
- Create, Change, Delete, Cancel: 오브젝트를 생성하거나 변경하거나 지우거나 상태를 취소 상태를 만들 때 사용.
- AddItem, RemoveItem : 오브젝트 구조를 보면 헤더와 아이템으로 이뤄진 구조가 많음.    
아이템에 대해 더하거나 제거를 할 수 있는 기능.
  
### BAPI Explorer
BAPI를 검색할 때에는 BAPI Explorer를 사용하여 검색하면 됨.
BAPI Explorer의 T-Code는 BAPI임. 이걸 입력해서 BAPI Explorer로 접속이 가능함.     
좌측은 비즈니스 오브젝트에 대한 리스트들이 나타남.     
이 때 비즈니스 오브젝트를 변경할 수 있는 BAPI들이 나타나는 데 Change에 대한 것을 더블클릭하면,
실제로 BAPI에 대한 내용이 나타남.     

이때 함수 모듈을 봐야 함. BAPI는 함수 모듈로 구현되기 때문.      
이 함수모듈을 클릭해보면 함수 빌더에서 해당 함수를 조회해볼 수 있음.     

### BAPI 함수모듈
일반 함수모듈과 다르게 제약사항이 있음.      
BAPI함수그룹은 스크린 사용이 안 됨.    
속성에서 BAPI를 외부에서 호출할 수 있도록 remort enabled가 체크되어 있어야 함.    
BAPI함수 모듈에는 예외가 올 수 없음.    
만약 오류가 났을 경우, EXPORT 파라미터에 RETURN 키워드를 주고 structure와 internal table에 무엇때문에 에러가 났는지 해당 정보를 넣어둬야 함.    

Importing과 exporting 파라미터는 사용 가능하나, exception과 changing은 안 됨.    
BAPI의 인터페이스에 오는 타입은 딕셔너리에 정의된 타입이어야 하며, BAPI_로 시작하는 Prefix여야 함.    

### ABAP 프로그램에서 BAPI를 Call하는 방법
BAPI도 함수 모듈임.    
따라서 패턴을 통해 BAPI_함수모듈 이름을 사용하면 쉽게 호출할 수 있음.

### Lesson6. 글로벌 클래스의 메소드 호출
#### 클래스의 구조
클래스는 속성과 메소드로 이루어져 있음.     
속성은 함수그룹에서 데이터 오브젝트임.   
메소드는 함수그룹에서 함수 모듈이라고 보면 됨.    

클래스는 속성과 메소드로 이뤄져 있는데, 이 둘을 합쳐서 클래스의 컴포넌트라고 부름.    
또한, 클래스는 함수 그룹과 다르게 visability를 지정해 줄 수 있음.     
Visability는 해당 visability에 해당하는 메소드와 어트리뷰트(속성)이 접근할 수 있는 범위가 어디까지인지를 규정해주는 키워드임.     
Public 키워드 밑에 Components(어트리뷰트와 메소드)를 나열하면, 그 컴포넌트는 클래스 외부 / 내부 상관없이 접근이 가능함.     
Private 키워드 밑에 Components(어트리뷰트와 메소드)를 나열하면, 그 컴포넌트는 클래스 내부에서만 접근이 가능함.    

### Class와 Object 사이를 설명하는 장표
클래스, 오브젝트, 인스턴스는 모두 같은 단어라고 생각해도 무방.      
클래스와 오브젝트와의 관계는 데이터 타입과 데이터 오브젝트의 관계, 
클래스는 하나의 틀이고, 오브젝트는 그 클래스로부터 실체가 있는 것으로 나온 것을 의미.      
하나의 클래스로부터 여러 개의 오브젝트를 생성가능.       
이 오브젝트들은 서로 다른 메모리 영역에 잡히므로 전부 독립적인 것으로 봐야 함.     

### 클래스의 일부 중 하나인 Attribute(속성, 어트리뷰트)를 정의하는 방법
클래스 빌더(=SE24)에서 수정 가능.      
그 곳에서 Attribute를 눌러 정의할 수 있는데, 레벨 : static - 오브젝트가 생성되지 않아도 접근 가능, instance - 오브젝트가 생성되어야 접근 가능 / 이름 / 어트리뷰트 타입 / visibility등을 설정 가능    
(+) 메소드를 정의하는 방법 : 메소드 탭에서 메소드 이름을 넣고, 클래스처럼 레벨을 작업하면 됨. / visibility(프라이빗, 퍼블릭), 묘사 작성 

### 메소드 파라미터 정의법
메소드 파라미터를 정의하기 위해서는 메소드에 커서를 가져다 대고, 파라미터 버튼을 누르면 파라미터 입력 가능한 화면으로 넘어감.    
파라미터를 입력하는 창은 함수 모듈과 조금 다름.    
타입이라는 칼럼이 있음. 여기서 선택하여 작성해주면 됨.     
파라미터 타입 역시 글로벌 타입이어야 함.

### 메소드의 예외 등록
메소드에 커서 대고, 예외 버튼을 누르면 예외 목록을 나열할 수 있음.     
이 때 예외 타입에는 두 가지가 있음.    
- 클래식 : 체크 박스를 안 찍어주면 클래식 예외처리
- 클래스 베이스드 익셉션 : 체크박스를 눌렀을 경우 예외처리

### 클래스의 메소드 테스트
클래스 빌더에서 실행버튼을 누르면 메소드 리스트가 보이고, 실행버튼을 누르면 import 파라미터가 있다면 입력할 수 있는 창이 나타남.
거기에 값을 입력하고 실행버튼을 누르면 export 파라미터에 대한 결과 값을 볼 수 있음.

### 메소드 호출하는 방법
좌측에 메소드가 보이면, 메소드를 드래그 & 드롭해서 오른쪽에 클래스 템플릿이 나타남.    
원하는 위치에 변수만 매핑해주면 됨.   

### 예외처리 방법
#### 클래식 예외처리
함수 모듈에서 예외처리했던 방법과 동일함.     
Sy-subrc값으로 예외처리 진행하면 됨.
- 클래스 기반 예외처리 : 체크박스가 활성화된 클래스의 예외처리     
TRY - ENDTRY 구문을 사용하여 메소드 호출하는 부분을 넣고, 
CATCH 구문을 사용하여 get_power에서 나타날 수 있는 예외들을 잡아주면 됨.    
이 메소드가 실행되는 동안 예외처리가 발생하면 캐치 블록에 걸리게 되며, 메시지가 출력됨.     
  
### 예외가 있는 클래스의 메소드
이 경우 예외처리를 해줘야 하는데, 드래그 & 드롭해주면 예외처리가 이미 되어서 나옴.     
단, 주석 처리가 되어 있으므로 주석 풀고 코딩하면 됨.

###클래스의 인스턴스를 생성하는 방법
위에 레퍼런스 변수를 생성.    
클래스 인스턴스를 생성하기 위해서는 꼭 레퍼런스 변수를 사용해야 함!    
DATE 키워드를 사용하되, TYPE REF로 지정해야 함.     
`DATA 레퍼런스변수명 TYPE REF TO 클래스`      

REF1이라는 레퍼런스 변수를 선언하는데, myclass라는 것을 통해 나온 인스턴스를 레퍼런스, 
즉 포인팅할 수 있게끔 만들어 줄 변수를 선언하라는 의미.      
(참조용 변수를 선언하라는 의미)     
CREATE OBJECT 구문을 만나기 전까지는 해당 변수는 변수 메모리만 잡히고 아무것도 참고하고 있지 않지만,     
CREATE OBJECT 구문을 만날 경우 클래스에서 오브젝트를 생성하면서 레퍼런스 변수가 참고하고 있는 오브젝트가 생성됨.     

인스턴스 메서드의 경우, 클래스의 인스턴스가 생성되어야 하지만 메서드를 사용가능함.    
CREATE OBJECT로 인스턴스를 생성했으니 레퍼런스 변수가 가리키는 인스턴스의 특정 메소드를 호출하면 됨.    
스태틱 메소드는 이런 인스턴스 생성 작업이 필요없음.   

## Lesson 7. 글로벌 클래스와 스태틱 메소드를 생성하는 방법
### 글로벌 클래스
SE80, SE24에서 만들 수 있음.    
생성 시 ZCL로 시작하는 이름으로 됨.

### 소스코드 에디터로 들어가는 방법
메소드 더블클릭 : 메소드에 커서를 대고, 소스코드 에디터를 보는 버튼을 누르면 됨.     
소스코드 에디터에서 소스코드를 넣고, 이 메소드에 있는 파라미터를 보고 싶을 경우 시그니처 버튼을 누르면,     
이 메소드가 가진 파라미터들을 확인 가능함.

## Lesson8. 로컬 클래스의 사용법
로컬클래스는 로컬 모듈화 유닛을 만들기 위해 사용함.
### 로컬 클래스 정의법
글로벌 클래스와 다르게 전부 코딩해야 함.    
클래스라는 키워드로 클래스를 선언하면 되고, 정의부와 구현부. 이 두 섹션으로 나뉨.
- 정의부    
`CLASS 이름 DEFINITION … ENDCLASS`
    - 퍼블릭, 프라이빗 선언 가능
    
- 구현부     
  `CLASS 이름 IMPLEMENTATION … ENDCLASS`
  
### 클래스의 메소드를 정의하는 방법
정의부에서는 메소드의 정의 즉, 메소드가 가진 파라미터를 정의하면 됨.     
구현부에서는 메소드의 실제 소스코드를 정의하면 됨.     
`METHOD …(실제 소스코드)... END METHOD`

### 로컬 클래스의 스태틱 메소드 사용법
로컬 클래스의 메소드 호출하는 곳은 그 로컬 클래스의 메소드를 정의한 곳보다 항상 아래에 있어야 함.    
컴파일러가 그 클래스를 알 수 없기 때문.        트

 

 

 

 